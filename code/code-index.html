<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>源码分析</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body id="code" class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>源码分析</h1>
<div class="details">
<span id="revnumber"> 0.0.1-SNAPSHOT</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<span id="back-to-index"><a href="../index.html">Back to index</a></span><ul class="sectlevel1">
<li><a href="#cat日志路径">1. cat日志路径</a></li>
<li><a href="#springboot自动装配的机制">2. springboot自动装配的机制</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="cat日志路径"><a class="anchor" href="#cat日志路径"></a>1. cat日志路径</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>从plexus获取日志路径配置</p>
<div class="paragraph">
<p><span class="image"><img src="../images/image-20211125173001198.png" alt="image-20211125173001198"></span></p>
</div>
</li>
<li>
<p>日志配置如下</p>
<div class="paragraph">
<p><span class="image"><img src="../images/image-20211125173103300.png" alt="image-20211125173103300"></span></p>
</div>
</li>
<li>
<p>同时提供了可以覆盖日志路径的变量</p>
<div class="paragraph">
<p><span class="image"><img src="../images/image-20211125173258219.png" alt="image-20211125173258219"></span></p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="springboot自动装配的机制"><a class="anchor" href="#springboot自动装配的机制"></a>2. springboot自动装配的机制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>自动装配在Spring Boot中非常重要，是Spring Boot starters的基石，本文将从一个业务问题解析自动装配的机制。</p>
</div>
<div class="paragraph">
<p>先说结论：</p>
</div>
<div class="paragraph">
<p>Spring Boot项目bean注册顺序</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>启动类(一般是被@SpringBootApplication注解的类)以及其包下的bean</p>
</li>
<li>
<p>自动装配的bean</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果有多个自动装配的类，按如下顺序</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>先通过字母顺序排序</p>
</li>
<li>
<p>再通过定义的order顺序排序(参见@AutoConfigureOrder)</p>
</li>
<li>
<p>再通过@AutoConfigureBefore @AutoConfigureAfter排序</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>根据该顺序，再结合@ConditionalOnMissingBean，@ConditionalOnMissingClass等条件注解，即可完成自动装配，达到约定大于配置的效果。</p>
</div>
<div class="paragraph">
<p>最近业务同学反馈了一个这样的问题</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name 'methodValidationPostProcessor'...

//省略若干日志
Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述日志显示，com.ke.talent.common.rest.config包下的ValidatorConfiguration.class中定义了一个bean，和Spring Boot自动装配中的bean发生了bean定义冲突。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.ke.talent.common.rest.config;
//省略若干代码

@Configuration
public class ValidatorConfiguration {
//省略若干代码
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor();
        postProcessor.setValidator(this.validator());
        return postProcessor;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一直觉是，Spring Boot自动装配不是有一个@ConditionalOnMissingBean条件吗，如下所示，在org.springframework.boot.autoconfigure.validation包下查看ValidationAutoConfiguration类。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
@ConditionalOnMissingBean
public static MethodValidationPostProcessor methodValidationPostProcessor(Environment environment,
                                                                          @Lazy Validator validator) {
  MethodValidationPostProcessor processor = new MethodValidationPostProcessor();
  boolean proxyTargetClass = environment.getProperty("spring.aop.proxy-target-class", Boolean.class, true);
  processor.setProxyTargetClass(proxyTargetClass);
  processor.setValidator(validator);
  return processor;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>正常来说，如果我们已经在应用中配置了MethodValidationPostProcessor类型的bean，那么上述代码所定义的bean就不会再被注册。</p>
</div>
<div class="paragraph">
<p>查阅@ConditionalOnMissingBean的java doc</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The condition can only match the bean definitions that have been processed by the application context so far and, as such, it is strongly recommended to use this condition on auto-configuration classes only. If a candidate bean may be created by another auto-configuration, make sure that the one using this condition runs after.</p>
</div>
<div class="paragraph">
<p>译文：该条件只能匹配到目前为止已由应用程序上下文处理的 bean 定义，因此，强烈建议仅在自动配置类上使用此条件。 如果候选 bean 可能是由另一个自动配置创建的，请确保使用此条件的那个 bean 之后运行。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>简而言之，要想@ConditionalOnMissingBean生效，被@ConditionalOnMissingBean注解的bean必须是后注册的</p>
</div>
<div class="paragraph">
<p>&lt;font color="#dd0000"&gt;但根据上述报错表明，实际情况是Spring Boot自动装配的bean先注册了，之后Spring才扫描到com.ke.talent.common.rest.config包下的ValidatorConfiguration.class，而ValidatorConfiguration中的bean定义没有任何条件注解，且类型和名称都与Spring Boot自动装配的bean相同，因此提示bean重复定义的异常&lt;/font&gt;</p>
</div>
<div class="paragraph">
<p>为什么会出现这样的情况？</p>
</div>
<div class="paragraph">
<p>经过调查，发现com.ke.talent.common.rest.config.ValidatorConfiguration也是通过自动装配注入的</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image1.png" alt="image.png"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image2.png" alt="image.png"></span></p>
</div>
<div class="paragraph">
<p>那么两个自动装配的bean的加载顺序是怎么决定的呢？通过debug，阅读源码发现此处决定了自动装配的顺序org.springframework.boot.autoconfigure.AutoConfigurationSorter#getInPriorityOrder</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    public List&lt;String&gt; getInPriorityOrder(Collection&lt;String&gt; classNames) {
        AutoConfigurationClasses classes = new AutoConfigurationClasses(this.metadataReaderFactory,
                this.autoConfigurationMetadata, classNames);
        List&lt;String&gt; orderedClassNames = new ArrayList&lt;&gt;(classNames);
        // Initially sort alphabetically
        Collections.sort(orderedClassNames);
        // Then sort by order
        orderedClassNames.sort((o1, o2) -&gt; {
            int i1 = classes.get(o1).getOrder();
            int i2 = classes.get(o2).getOrder();
            return Integer.compare(i1, i2);
        });
        // Then respect @AutoConfigureBefore @AutoConfigureAfter
        orderedClassNames = sortByAnnotation(classes, orderedClassNames);
        return orderedClassNames;
    }
</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>先通过字母顺序排序</p>
</li>
<li>
<p>再通过定义的order顺序排序(参见@AutoConfigureOrder)</p>
</li>
<li>
<p>再通过@AutoConfigureBefore @AutoConfigureAfter排序</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>经过这样的排序后，org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration排在了com.ke.talent.common.rest.TalentRestConfiguration前面，以上。</p>
</div>
<div class="paragraph">
<p>因此提供三方包的同学应该注意了，必须避免这种冲突，方案可以是下述之一</p>
</div>
<div class="ulist">
<ul>
<li>
<p>（推荐）提供组件，但让业务方自己在项目中显式注册</p>
</li>
<li>
<p>（不推荐）如果真的想用自己的自动装配覆盖Spring Boot的自动装配，可以通过上面的排序规则，让自己的自动装配class排到Spring Boot提供的自动装配class前面。但你必须告诉引用你的包的人，你做了哪些更改，因为项目如果原本使用的是springboot自动装配的bean，你的覆盖可能会导致问题，因此这是非常不建议的行为。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来继续讨论，为什么我们平时写在项目中的bean定义，就可以覆盖Spring Boot自动装配的bean定义呢？是什么保证了我们写在项目中的bean在自动装配的bean之前注册呢？</p>
</div>
<div class="paragraph">
<p>这个需要从启动类开始分析，如下</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image3.png" alt="image.png"></span></p>
</div>
<div class="paragraph">
<p>SpringApplication将Application这个类作为参数传入，而这个类上有一个@SpringCloudApplication注解，继续追踪该注解，发现其元注解包括</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image4.png" alt="iamge"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image5.png" alt="image.png"></span></p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image6.png" alt="image.png"></span></p>
</div>
<div class="paragraph">
<p>注意这两个元注解</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该注解在没有指定扫描的包的情况下，会将被注解类的包路径作为扫描的包</p>
</div>
<div class="ulist">
<ul>
<li>
<p>@Import(AutoConfigurationImportSelector.class)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>该注解会扫描自动装配的bean</p>
</div>
<div class="paragraph">
<p>Debug，阅读源码，找到核心代码段org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../images/image7.png" alt="image.png"></span></p>
</div>
<div class="paragraph">
<p>由于代码逻辑还是比较多的，这里不再展开，仅说明这两处代码做了什么事情。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>167行代码，解析Application类</p>
</li>
<li>
<p>解析发现@ComponentScan，扫描注册Application类对应的包路径的bean</p>
</li>
<li>
<p>解析发现@Import(AutoConfigurationImportSelector.class)，初始化185行的deferredImportSelectorHandler</p>
</li>
<li>
<p>185行代码，deferredImportSelectorHandler中的AutoConfigurationImportSelector会执行自动装配的逻辑，从META-INF/spring.factories下找到需要自动装配的bean</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此处代码决定了Application包目录下的bean注册早于自动装配的bean，以上。</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
 0.0.1-SNAPSHOT<br>
Last updated 2022-01-26 14:14:07 UTC
</div>
</div>
</div>
  </div>
</div>
</body>
</html>